/*	Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.	Licensed under the Amazon Software License (the "License"). You may not use this file except	in compliance with the License. A copy of the License is located at		http://aws.amazon.com/asl/	or in the "LICENSE.txt" file accompanying this file.	This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,	express or implied. See the License for the specific language governing permissions and	limitations under the License.*//* * This code sample demonstrates an implementation of the Lex Code Hook Interface * in order to serve a bot which is used to order coffee. * * For instructions on how to set up and test this bot, as well as additional samples, *  visit the Lex Getting Started documentation. * * This example is intentionally simplistic for illustration; please consider using * the Amazon Lex blueprints for your projects. */'use strict';// --------------- Helpers to build responses which match the structure of the necessary dialog actions -----------------------function elicitSlot(sessionAttributes, intentName, slots, slotToElicit, message, responseCard) {	return {		sessionAttributes,		dialogAction: {			type: 'ElicitSlot',			intentName,			slots,			slotToElicit,			message,			responseCard,		},	};}function confirmIntent(sessionAttributes, intentName, slots, message, responseCard) {	return {		sessionAttributes,		dialogAction: {			type: 'ConfirmIntent',			intentName,			slots,			message,			responseCard,		},	};}function close(sessionAttributes, fulfillmentState, message, responseCard) {	return {		sessionAttributes,		dialogAction: {			type: 'Close',			fulfillmentState,			message,			responseCard,		},	};}function delegate(sessionAttributes, slots) {	return {		sessionAttributes,		dialogAction: {			type: 'Delegate',			slots,		},	};}// ---------------- Helper Functions --------------------------------------------------// build a message for Lex responsesfunction buildMessage(messageContent) {    return {		contentType: 'PlainText',		content: messageContent,    };}// Build a responseCard with a title, subtitle, and an optional set of options which should be displayed as buttons.function buildResponseCard(title, subTitle, options) {    let buttons = null;    if (options !== null) {        buttons = [];        for (let i = 0; i < Math.min(5, options.length); i++) {            buttons.push(options[i]);        }    }    return {        contentType: 'application/vnd.amazonaws.card.generic',        version: 1,        genericAttachments: [{            title,            subTitle,            buttons,        }],    };}function buildResponseOptions(optionsArray = Array){    var responseOptions = [];    for(var i=0; i<optionsArray.length; i++){        var temp = {            "text": optionsArray[i],            "value": optionsArray[i]        }        responseOptions.push(temp);    }    return responseOptions;}function keyExists(key, search) {    if (!search || (search.constructor !== Array && search.constructor !== Object)) {        return false;    }    for (var i = 0; i < search.length; i++) {        if (search[i] === key) {            return true;        }    }    return key in search;}// --------------- Functions that control the skill's behavior -----------------------/** * Performs dialog management and fulfillment for ordering a beverage. * (we only support ordering a mocha for now) */function recordReceipt(intentRequest, callback) {	const outputSessionAttributes = intentRequest.sessionAttributes;	const source = intentRequest.invocationSource;	const status = intentRequest.currentIntent.confirmationStatus;	var slots 		= intentRequest.currentIntent.slots;	var requestAttr = intentRequest.requestAttributes;	if (source === 'DialogCodeHook') {		// perform validation on the slot values we have		if(Object.keys(requestAttr).length > 0){			console.log("Found requestAttr")			slots.amountType 		= (requestAttr.amountType ? requestAttr.amountType : null);			slots.receiptType 		= (requestAttr.receiptType ? requestAttr.receiptType : null);			slots.merchantType 		= (requestAttr.merchantType ? requestAttr.merchantType : null);			slots.amountCurrency 	= (requestAttr.amountCurrency ? requestAttr.amountCurrency : null);			slots.receiptdateType 	= (requestAttr.receiptdateType ? requestAttr.receiptdateType : null);		}		if(status === 'Confirmed') {			callback(close(outputSessionAttributes, 'Fulfilled', {				contentType: 'PlainText',				content: `Great!  Your receipt is securely stored.  Thanks for using Expense Bot!`			}));			return;		}		// if we've come this far, then we simply defer to Lex		callback(delegate(outputSessionAttributes, slots));		return;	}}// --------------- Intents -----------------------/** * Called when the user specifies an intent for this skill. */function dispatch(intentRequest, callback) {	console.log(`dispatch userId=${intentRequest.userId}, intent=${intentRequest.currentIntent.name}`);	const name = intentRequest.currentIntent.name;	// dispatch to the intent handlers	if (name.startsWith('recordReceipt')) {		return recordReceipt(intentRequest, callback);	}	throw new Error(`Intent with name ${name} not supported`);}// --------------- Main handler -----------------------// Route the incoming request based on intent.// The JSON body of the request is provided in the event slot.exports.expensy_init = (event, context, callback) => {	console.log(JSON.stringify(event));	const env_variables = {    BOT_NAME: process.env.BOT_NAME,    BOT_ALIAS: process.env.BOT_ALIAS,	}	try {		console.log(`event.bot.name=${event.bot.name}`);		// fail if this function is for a different bot		if(! event.bot.name.startsWith(env_variables.BOT_NAME)) {      callback('Invalid Bot Name');		}		dispatch(event, (response) => callback(null, response));	} catch (err) {		console.log("Error init:", err)		callback(err);	}};